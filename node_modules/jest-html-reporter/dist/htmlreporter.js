"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dateformat_1 = __importDefault(require("dateformat"));
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const xmlbuilder_1 = __importDefault(require("xmlbuilder"));
const sortingMethods_1 = require("./sortingMethods");
class HTMLReporter {
    constructor(testData, options) {
        this.testData = testData;
        this.setupConfig(options);
    }
    async generate() {
        const report = await this.renderTestReport();
        const outputPath = this.getConfigValue("outputPath");
        await mkdirp_1.default(path_1.default.dirname(outputPath));
        await fs_1.default.writeFile(outputPath, report, writeFileError => {
            if (writeFileError) {
                throw new Error(`Something went wrong when creating the file: ${writeFileError}`);
            }
        });
        this.logMessage("success", `Report generated (${outputPath})`);
    }
    async renderTestReport() {
        try {
            // Generate the content of the test report
            const reportBody = await this.renderTestReportBody();
            // --
            // Boilerplate Option
            if (!!this.getConfigValue("boilerplate")) {
                const boilerplateContent = await this.getFileContent(this.getConfigValue("boilerplate"));
                return boilerplateContent.replace("{jesthtmlreporter-content}", reportBody.toString());
            }
            // --
            // Create HTML and apply reporter content
            const HTMLBase = {
                html: {
                    head: {
                        meta: { "@charset": "utf-8" },
                        title: { "#text": this.getConfigValue("pageTitle") },
                        style: undefined,
                        link: undefined
                    }
                }
            };
            // Default to the currently set theme
            let stylesheetFilePath = path_1.default.join(__dirname, `../style/${this.getConfigValue("theme")}.css`);
            // Overriding stylesheet
            if (this.getConfigValue("styleOverridePath")) {
                stylesheetFilePath = this.getConfigValue("styleOverridePath");
            }
            // Decide whether to inline the CSS or not
            const inlineCSS = !this.getConfigValue("useCssFile") &&
                !!!this.getConfigValue("styleOverridePath");
            if (inlineCSS) {
                const stylesheetContent = await fs_1.default.readFileSync(stylesheetFilePath, "utf8");
                HTMLBase.html.head.style = {
                    "@type": "text/css",
                    "#text": stylesheetContent
                };
            }
            else {
                HTMLBase.html.head.link = {
                    "@rel": "stylesheet",
                    "@type": "text/css",
                    "@href": stylesheetFilePath
                };
            }
            const report = xmlbuilder_1.default.create(HTMLBase);
            report.ele("body").raw(reportBody.toString());
            return report;
        }
        catch (e) {
            this.logMessage("error", e);
            return;
        }
    }
    async renderTestReportBody() {
        try {
            if (!this.testData) {
                throw Error("No test data provided");
            }
            // HTML Body
            const reportBody = xmlbuilder_1.default.begin().element("div", {
                id: "jesthtml-content"
            });
            /**
             * Page Header
             */
            const header = reportBody.ele("header");
            // Page Title
            header.ele("h1", { id: "title" }, this.getConfigValue("pageTitle"));
            // Logo
            const logo = this.getConfigValue("logo");
            if (logo) {
                header.ele("img", { id: "logo", src: logo });
            }
            /**
             * Meta-Data
             */
            const metaDataContainer = reportBody.ele("div", {
                id: "metadata-container"
            });
            // Timestamp
            const timestamp = new Date(this.testData.startTime);
            metaDataContainer.ele("div", { id: "timestamp" }, `Start: ${dateformat_1.default(timestamp.toDateString(), this.getConfigValue("dateFormat"))}`);
            // Test Summary
            metaDataContainer.ele("div", { id: "summary" }, `${this.testData.numTotalTests} tests -- ${this.testData.numPassedTests} passed / ${this.testData.numFailedTests} failed / ${this.testData.numPendingTests} pending`);
            /**
             * Apply any given sorting method to the test results
             */
            const sortedTestResults = sortingMethods_1.sortTestResults(this.testData.testResults, this.getConfigValue("sort"));
            /**
             * Setup ignored test result statuses
             */
            const statusIgnoreFilter = this.getConfigValue("statusIgnoreFilter");
            let ignoredStatuses = [];
            if (statusIgnoreFilter) {
                ignoredStatuses = statusIgnoreFilter
                    .replace(/\s/g, "")
                    .toLowerCase()
                    .split(",");
            }
            /**
             * Test Suites
             */
            sortedTestResults.map(suite => {
                // Filter out the test results with statuses that equals the statusIgnoreFilter
                for (const [i, result] of suite.testResults.entries()) {
                    if (ignoredStatuses.includes(result.status)) {
                        suite.testResults.splice(i, 1);
                    }
                }
                // Ignore this suite if there are no results
                if (!suite.testResults || suite.testResults.length <= 0) {
                    return;
                }
                // Suite Information
                const suiteInfo = reportBody.ele("div", { class: "suite-info" });
                // Suite Path
                suiteInfo.ele("div", { class: "suite-path" }, suite.testFilePath);
                // Suite execution time
                const executionTime = (suite.perfStats.end - suite.perfStats.start) / 1000;
                suiteInfo.ele("div", { class: `suite-time${executionTime > 5 ? " warn" : ""}` }, `${executionTime}s`);
                // Suite Test Table
                const suiteTable = reportBody.ele("table", {
                    class: "suite-table",
                    cellspacing: "0",
                    cellpadding: "0"
                });
                // Test Results
                suite.testResults.forEach(test => {
                    const testTr = suiteTable.ele("tr", { class: test.status });
                    // Suite Name(s)
                    testTr.ele("td", { class: "suite" }, test.ancestorTitles.join(" > "));
                    // Test name
                    const testTitleTd = testTr.ele("td", { class: "test" }, test.title);
                    // Test Failure Messages
                    if (test.failureMessages &&
                        this.getConfigValue("includeFailureMsg")) {
                        const failureMsgDiv = testTitleTd.ele("div", {
                            class: "failureMessages"
                        });
                        test.failureMessages.forEach(failureMsg => {
                            failureMsgDiv.ele("pre", { class: "failureMsg" }, strip_ansi_1.default(failureMsg));
                        });
                    }
                    // Append data to <tr>
                    testTr.ele("td", { class: "result" }, test.status === "passed"
                        ? `${test.status} in ${test.duration / 1000}s`
                        : test.status);
                });
                // All console.logs caught during the test run
                if (this.consoleLogList &&
                    this.consoleLogList.length > 0 &&
                    this.getConfigValue("includeConsoleLog")) {
                    // Filter out the logs for this test file path
                    const filteredConsoleLogs = this.consoleLogList.find(logs => logs.filePath === suite.testFilePath);
                    if (filteredConsoleLogs && filteredConsoleLogs.logs.length > 0) {
                        // Console Log Container
                        const consoleLogContainer = reportBody.ele("div", {
                            class: "suite-consolelog"
                        });
                        // Console Log Header
                        consoleLogContainer.ele("div", { class: "suite-consolelog-header" }, "Console Log");
                        // Apply the logs to the body
                        filteredConsoleLogs.logs.forEach(log => {
                            const logElement = consoleLogContainer.ele("div", {
                                class: "suite-consolelog-item"
                            });
                            logElement.ele("pre", { class: "suite-consolelog-item-origin" }, strip_ansi_1.default(log.origin));
                            logElement.ele("pre", { class: "suite-consolelog-item-message" }, strip_ansi_1.default(log.message));
                        });
                    }
                }
            });
            return reportBody;
        }
        catch (e) {
            this.logMessage("error", e);
        }
    }
    /**
     * Fetch and setup configuration
     */
    setupConfig(options) {
        this.config = {
            append: {
                defaultValue: false,
                environmentVariable: "JEST_HTML_REPORTER_APPEND",
                configValue: options.append
            },
            boilerplate: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_BOILERPLATE",
                configValue: options.boilerplate
            },
            customScriptPath: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_CUSTOM_SCRIPT_PATH",
                configValue: options.customScriptPath
            },
            dateFormat: {
                defaultValue: "yyyy-mm-dd HH:MM:ss",
                environmentVariable: "JEST_HTML_REPORTER_DATE_FORMAT",
                configValue: options.dateFormat
            },
            executionTimeWarningThreshold: {
                defaultValue: 5,
                environmentVariable: "JEST_HTML_REPORTER_EXECUTION_TIME_WARNING_THRESHOLD",
                configValue: options.executionTimeWarningThreshold
            },
            logo: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_LOGO",
                configValue: options.logo
            },
            includeFailureMsg: {
                defaultValue: false,
                environmentVariable: "JEST_HTML_REPORTER_INCLUDE_FAILURE_MSG",
                configValue: options.includeFailureMsg
            },
            includeConsoleLog: {
                defaultValue: false,
                environmentVariable: "JEST_HTML_REPORTER_INCLUDE_CONSOLE_LOG",
                configValue: options.includeConsoleLog
            },
            outputPath: {
                defaultValue: path_1.default.join(process.cwd(), "test-report.html"),
                environmentVariable: "JEST_HTML_REPORTER_OUTPUT_PATH",
                configValue: options.outputPath
            },
            pageTitle: {
                defaultValue: "Test Report",
                environmentVariable: "JEST_HTML_REPORTER_PAGE_TITLE",
                configValue: options.pageTitle
            },
            theme: {
                defaultValue: "defaultTheme",
                environmentVariable: "JEST_HTML_REPORTER_THEME",
                configValue: options.theme
            },
            sort: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_SORT",
                configValue: options.sort
            },
            statusIgnoreFilter: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_STATUS_FILTER",
                configValue: options.statusIgnoreFilter
            },
            styleOverridePath: {
                defaultValue: null,
                environmentVariable: "JEST_HTML_REPORTER_STYLE_OVERRIDE_PATH",
                configValue: options.styleOverridePath
            },
            useCssFile: {
                defaultValue: false,
                environmentVariable: "JEST_HTML_REPORTER_USE_CSS_FILE",
                configValue: options.useCssFile
            }
        };
        // Attempt to collect and assign config settings from jesthtmlreporter.config.json
        try {
            const jesthtmlreporterconfig = fs_1.default.readFileSync(path_1.default.join(process.cwd(), "jesthtmlreporter.config.json"), "utf8");
            if (jesthtmlreporterconfig) {
                const parsedConfig = JSON.parse(jesthtmlreporterconfig);
                for (const key of Object.keys(parsedConfig)) {
                    if (this.config[key]) {
                        this.config[key].configValue =
                            parsedConfig[key];
                    }
                }
                return;
            }
        }
        catch (e) {
            /** do nothing */
        }
        // If above method did not work we attempt to check package.json
        try {
            const packageJson = fs_1.default.readFileSync(path_1.default.join(process.cwd(), "package.json"), "utf8");
            if (packageJson) {
                const parsedConfig = JSON.parse(packageJson)["jest-html-reporter"];
                for (const key of Object.keys(parsedConfig)) {
                    if (this.config[key]) {
                        this.config[key].configValue =
                            parsedConfig[key];
                    }
                }
            }
        }
        catch (e) {
            /** do nothing */
        }
    }
    /**
     * Returns the configurated value from the config in the following priority order:
     * Environment Variable > JSON configured value > Default value
     * @param key
     */
    getConfigValue(key) {
        const option = this.config[key];
        if (!option) {
            return;
        }
        if (process.env[option.environmentVariable]) {
            return process.env[option.environmentVariable];
        }
        return option.configValue || option.defaultValue;
    }
    async getFileContent(filePath) {
        try {
            fs_1.default.readFile(filePath, "utf8", (err, content) => {
                if (err) {
                    throw Error(`Could not locate file: '${filePath}': ${err}`);
                }
                return content;
            });
        }
        catch (e) {
            this.logMessage("error", e);
            return;
        }
    }
    /**
     * Method for logging to the terminal
     * @param type
     * @param message
     * @param ignoreConsole
     */
    logMessage(type = "default", message, ignoreConsole) {
        const logTypes = {
            default: "\x1b[37m%s\x1b[0m",
            success: "\x1b[32m%s\x1b[0m",
            error: "\x1b[31m%s\x1b[0m"
        };
        const logColor = !logTypes[type] ? logTypes.default : logTypes[type];
        const logMsg = `jest-html-reporter >> ${message}`;
        if (!ignoreConsole) {
            console.log(logColor, logMsg);
        }
        return { logColor, logMsg }; // Return for testing purposes
    }
}
exports.default = HTMLReporter;
//# sourceMappingURL=htmlreporter.js.map