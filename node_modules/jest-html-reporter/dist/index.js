'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dateformat = _interopDefault(require('dateformat'));
var fs = _interopDefault(require('fs'));
var mkdirp = _interopDefault(require('mkdirp'));
var path = _interopDefault(require('path'));
var stripAnsi = _interopDefault(require('strip-ansi'));
var xmlbuilder = _interopDefault(require('xmlbuilder'));

var sorting = ((testResults, sortType) => {
  const sortTypeLowercase = sortType && sortType.toLowerCase();

  switch (sortTypeLowercase) {
    case "status":
      return sortByStatus(testResults);

    case "executiondesc":
      return sortByExecutionDesc(testResults);

    case "executionasc":
      return sortByExecutionAsc(testResults);

    case "titledesc":
      return sortByTitleDesc(testResults);

    case "titleasc":
      return sortByTitleAsc(testResults);

    default:
      return testResults;
  }
});
/**
 * Splits test suites apart based on individual test status and sorts by that status:
 * 1. Pending
 * 2. Failed
 * 3. Passed
 */

const sortByStatus = testResults => {
  const pendingSuites = [];
  const failingSuites = [];
  const passingSuites = [];
  testResults.forEach(result => {
    const pending = [];
    const failed = [];
    const passed = [];
    result.testResults.forEach(x => {
      if (x.status === "pending") {
        pending.push(x);
      } else if (x.status === "failed") {
        failed.push(x);
      } else {
        passed.push(x);
      }
    });

    if (pending.length > 0) {
      pendingSuites.push({ ...result,
        testResults: pending
      });
    }

    if (failed.length > 0) {
      failingSuites.push({ ...result,
        testResults: failed
      });
    }

    if (passed.length > 0) {
      passingSuites.push({ ...result,
        testResults: passed
      });
    }
  });
  return [].concat(pendingSuites, failingSuites, passingSuites);
};
/**
 * Sorts by Execution Time | Descending
 */


const sortByExecutionDesc = testResults => {
  if (testResults) {
    testResults.sort((a, b) => b.perfStats.end - b.perfStats.start - (a.perfStats.end - a.perfStats.start));
  }

  return testResults;
};
/**
 * Sorts by Execution Time | Ascending
 */


const sortByExecutionAsc = testResults => {
  if (testResults) {
    testResults.sort((a, b) => a.perfStats.end - a.perfStats.start - (b.perfStats.end - b.perfStats.start));
  }

  return testResults;
};
/**
 * Sorts by Suite filename and Test name | Descending
 */


const sortByTitleDesc = testResults => {
  if (testResults) {
    // Sort Suites
    const sorted = testResults.sort((a, b) => sortAlphabetically(a.testFilePath, b.testFilePath, true)); // Sort Suite testResults

    sorted.forEach(suite => {
      suite.testResults.sort((a, b) => sortAlphabetically(a.ancestorTitles.join(" "), b.ancestorTitles.join(" "), true));
    });
    return sorted;
  }

  return testResults;
};
/**
 * Sorts by Suite filename and Test name | Ascending
 */


const sortByTitleAsc = testResults => {
  if (testResults) {
    // Sort Suites
    const sorted = testResults.sort((a, b) => sortAlphabetically(a.testFilePath, b.testFilePath)); // Sort Suite testResults

    sorted.forEach(suite => {
      suite.testResults.sort((a, b) => sortAlphabetically(a.ancestorTitles.join(" "), b.ancestorTitles.join(" ")));
    });
    return sorted;
  }

  return testResults;
};
/**
 * Helper sorting method
 */


const sortAlphabetically = (a, b, reversed = false) => {
  if (!reversed && a < b || reversed && a > b) {
    return -1;
  } else if (!reversed && a > b || reversed && a < b) {
    return 1;
  }

  return 0;
};

class HTMLReporter {
  constructor(testData, options, consoleLogs) {
    this.testData = testData;
    this.consoleLogList = consoleLogs;
    this.setupConfig(options);
  }

  async generate() {
    try {
      const report = await this.renderTestReport();
      const outputPath = this.getConfigValue("outputPath");
      await mkdirp(path.dirname(outputPath));

      if (this.getConfigValue("append")) {
        await fs.appendFileSync(outputPath, report);
      } else {
        await fs.writeFileSync(outputPath, report);
      }

      this.logMessage("success", `Report generated (${outputPath})`);
      return report;
    } catch (e) {
      this.logMessage("error", e);
    }
  }

  async renderTestReport() {
    // Generate the content of the test report
    const reportBody = await this.renderTestReportBody(); // --
    // Boilerplate Option

    if (!!this.getConfigValue("boilerplate")) {
      const boilerplateContent = await fs.readFileSync(this.getConfigValue("boilerplate"), "utf8");
      return boilerplateContent.replace("{jesthtmlreporter-content}", reportBody.toString());
    } // --
    // Create HTML and apply reporter content


    const HTMLBase = {
      html: {
        head: {
          meta: {
            "@charset": "utf-8"
          },
          title: {
            "#text": this.getConfigValue("pageTitle")
          },
          style: undefined,
          link: undefined
        }
      }
    }; // Default to the currently set theme

    let stylesheetFilePath = path.join(__dirname, `../style/${this.getConfigValue("theme")}.css`); // Overriding stylesheet

    if (this.getConfigValue("styleOverridePath")) {
      stylesheetFilePath = this.getConfigValue("styleOverridePath");
    } // Decide whether to inline the CSS or not


    const inlineCSS = !this.getConfigValue("useCssFile") && !!!this.getConfigValue("styleOverridePath");

    if (inlineCSS) {
      const stylesheetContent = await fs.readFileSync(stylesheetFilePath, "utf8");
      HTMLBase.html.head.style = {
        "@type": "text/css",
        "#text": stylesheetContent
      };
    } else {
      HTMLBase.html.head.link = {
        "@rel": "stylesheet",
        "@type": "text/css",
        "@href": stylesheetFilePath
      };
    }

    const report = xmlbuilder.create(HTMLBase);
    report.ele("body").raw(reportBody.toString());
    return report;
  }

  async renderTestReportBody() {
    try {
      if (!this.testData || Object.entries(this.testData).length === 0) {
        throw Error("No test data provided");
      } // HTML Body


      const reportBody = xmlbuilder.begin().element("div", {
        id: "jesthtml-content"
      });
      /**
       * Page Header
       */

      const header = reportBody.ele("header"); // Page Title

      header.ele("h1", {
        id: "title"
      }, this.getConfigValue("pageTitle")); // Logo

      const logo = this.getConfigValue("logo");

      if (logo) {
        header.ele("img", {
          id: "logo",
          src: logo
        });
      }
      /**
       * Meta-Data
       */


      const metaDataContainer = reportBody.ele("div", {
        id: "metadata-container"
      }); // Timestamp

      const timestamp = new Date(this.testData.startTime);
      metaDataContainer.ele("div", {
        id: "timestamp"
      }, `Start: ${dateformat(timestamp.toDateString(), this.getConfigValue("dateFormat"))}`); // Test Summary

      metaDataContainer.ele("div", {
        id: "summary"
      }, `${this.testData.numTotalTests} tests -- ${this.testData.numPassedTests} passed / ${this.testData.numFailedTests} failed / ${this.testData.numPendingTests} pending`);
      /**
       * Apply any given sorting method to the test results
       */

      const sortedTestResults = sorting(this.testData.testResults, this.getConfigValue("sort"));
      /**
       * Setup ignored test result statuses
       */

      const statusIgnoreFilter = this.getConfigValue("statusIgnoreFilter");
      let ignoredStatuses = [];

      if (statusIgnoreFilter) {
        ignoredStatuses = statusIgnoreFilter.replace(/\s/g, "").toLowerCase().split(",");
      }
      /**
       * Test Suites
       */


      sortedTestResults.map(suite => {
        // Ignore this suite if there are no results
        if (!suite.testResults || suite.testResults.length <= 0) {
          return;
        } // Suite Information


        const suiteInfo = reportBody.ele("div", {
          class: "suite-info"
        }); // Suite Path

        suiteInfo.ele("div", {
          class: "suite-path"
        }, suite.testFilePath); // Suite execution time

        const executionTime = (suite.perfStats.end - suite.perfStats.start) / 1000;
        suiteInfo.ele("div", {
          class: `suite-time${executionTime > 5 ? " warn" : ""}`
        }, `${executionTime}s`); // Suite Test Table

        const suiteTable = reportBody.ele("table", {
          class: "suite-table",
          cellspacing: "0",
          cellpadding: "0"
        }); // Test Results

        suite.testResults // Filter out the test results with statuses that equals the statusIgnoreFilter
        .filter(s => !ignoredStatuses.includes(s.status)).forEach(test => {
          const testTr = suiteTable.ele("tr", {
            class: test.status
          }); // Suite Name(s)

          testTr.ele("td", {
            class: "suite"
          }, test.ancestorTitles.join(" > ")); // Test name

          const testTitleTd = testTr.ele("td", {
            class: "test"
          }, test.title); // Test Failure Messages

          if (test.failureMessages && this.getConfigValue("includeFailureMsg")) {
            const failureMsgDiv = testTitleTd.ele("div", {
              class: "failureMessages"
            });
            test.failureMessages.forEach(failureMsg => {
              failureMsgDiv.ele("pre", {
                class: "failureMsg"
              }, stripAnsi(failureMsg));
            });
          } // Append data to <tr>


          testTr.ele("td", {
            class: "result"
          }, test.status === "passed" ? `${test.status} in ${test.duration / 1000}s` : test.status);
        }); // All console.logs caught during the test run

        if (this.consoleLogList && this.consoleLogList.length > 0 && this.getConfigValue("includeConsoleLog")) {
          // Filter out the logs for this test file path
          const filteredConsoleLogs = this.consoleLogList.find(logs => logs.filePath === suite.testFilePath);

          if (filteredConsoleLogs && filteredConsoleLogs.logs.length > 0) {
            // Console Log Container
            const consoleLogContainer = reportBody.ele("div", {
              class: "suite-consolelog"
            }); // Console Log Header

            consoleLogContainer.ele("div", {
              class: "suite-consolelog-header"
            }, "Console Log"); // Apply the logs to the body

            filteredConsoleLogs.logs.forEach(log => {
              const logElement = consoleLogContainer.ele("div", {
                class: "suite-consolelog-item"
              });
              logElement.ele("pre", {
                class: "suite-consolelog-item-origin"
              }, stripAnsi(log.origin));
              logElement.ele("pre", {
                class: "suite-consolelog-item-message"
              }, stripAnsi(log.message));
            });
          }
        }
      });
      return reportBody;
    } catch (e) {
      this.logMessage("error", e);
    }
  }
  /**
   * Fetch and setup configuration
   */


  setupConfig(options) {
    this.config = {
      append: {
        defaultValue: false,
        environmentVariable: "JEST_HTML_REPORTER_APPEND",
        configValue: options.append
      },
      boilerplate: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_BOILERPLATE",
        configValue: options.boilerplate
      },
      customScriptPath: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_CUSTOM_SCRIPT_PATH",
        configValue: options.customScriptPath
      },
      dateFormat: {
        defaultValue: "yyyy-mm-dd HH:MM:ss",
        environmentVariable: "JEST_HTML_REPORTER_DATE_FORMAT",
        configValue: options.dateFormat
      },
      executionTimeWarningThreshold: {
        defaultValue: 5,
        environmentVariable: "JEST_HTML_REPORTER_EXECUTION_TIME_WARNING_THRESHOLD",
        configValue: options.executionTimeWarningThreshold
      },
      logo: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_LOGO",
        configValue: options.logo
      },
      includeFailureMsg: {
        defaultValue: false,
        environmentVariable: "JEST_HTML_REPORTER_INCLUDE_FAILURE_MSG",
        configValue: options.includeFailureMsg
      },
      includeConsoleLog: {
        defaultValue: false,
        environmentVariable: "JEST_HTML_REPORTER_INCLUDE_CONSOLE_LOG",
        configValue: options.includeConsoleLog
      },
      outputPath: {
        defaultValue: path.join(process.cwd(), "test-report.html"),
        environmentVariable: "JEST_HTML_REPORTER_OUTPUT_PATH",
        configValue: options.outputPath
      },
      pageTitle: {
        defaultValue: "Test Report",
        environmentVariable: "JEST_HTML_REPORTER_PAGE_TITLE",
        configValue: options.pageTitle
      },
      theme: {
        defaultValue: "defaultTheme",
        environmentVariable: "JEST_HTML_REPORTER_THEME",
        configValue: options.theme
      },
      sort: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_SORT",
        configValue: options.sort
      },
      statusIgnoreFilter: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_STATUS_FILTER",
        configValue: options.statusIgnoreFilter
      },
      styleOverridePath: {
        defaultValue: null,
        environmentVariable: "JEST_HTML_REPORTER_STYLE_OVERRIDE_PATH",
        configValue: options.styleOverridePath
      },
      useCssFile: {
        defaultValue: false,
        environmentVariable: "JEST_HTML_REPORTER_USE_CSS_FILE",
        configValue: options.useCssFile
      }
    }; // Attempt to collect and assign config settings from jesthtmlreporter.config.json

    try {
      const jesthtmlreporterconfig = fs.readFileSync(path.join(process.cwd(), "jesthtmlreporter.config.json"), "utf8");

      if (jesthtmlreporterconfig) {
        const parsedConfig = JSON.parse(jesthtmlreporterconfig);

        for (const key of Object.keys(parsedConfig)) {
          if (this.config[key]) {
            this.config[key].configValue = parsedConfig[key];
          }
        }

        return;
      }
    } catch (e) {}
    /** do nothing */
    // If above method did not work we attempt to check package.json


    try {
      const packageJson = fs.readFileSync(path.join(process.cwd(), "package.json"), "utf8");

      if (packageJson) {
        const parsedConfig = JSON.parse(packageJson)["jest-html-reporter"];

        for (const key of Object.keys(parsedConfig)) {
          if (this.config[key]) {
            this.config[key].configValue = parsedConfig[key];
          }
        }
      }
    } catch (e) {
      /** do nothing */
    }
  }
  /**
   * Returns the configurated value from the config in the following priority order:
   * Environment Variable > JSON configured value > Default value
   * @param key
   */


  getConfigValue(key) {
    const option = this.config[key];

    if (!option) {
      return;
    }

    if (process.env[option.environmentVariable]) {
      return process.env[option.environmentVariable];
    }

    return option.configValue || option.defaultValue;
  }
  /**
   * Method for logging to the terminal
   * @param type
   * @param message
   * @param ignoreConsole
   */


  logMessage(type = "default", message, ignoreConsole) {
    const logTypes = {
      default: "\x1b[37m%s\x1b[0m",
      success: "\x1b[32m%s\x1b[0m",
      error: "\x1b[31m%s\x1b[0m"
    };
    const logColor = !logTypes[type] ? logTypes.default : logTypes[type];
    const logMsg = `jest-html-reporter >> ${message}`;

    if (!ignoreConsole) {
      console.log(logColor, logMsg);
    }

    return {
      logColor,
      logMsg
    }; // Return for testing purposes
  }

}

function JestHtmlReporter(globalConfig, options) {
  const consoleLogs = [];
  /**
   * If the first parameter has a property named 'testResults',
   * the script is being run as a 'testResultsProcessor'.
   * We then need to return the test results as they were received from Jest
   * https://facebook.github.io/jest/docs/en/configuration.html#testresultsprocessor-string
   */

  if (Object.prototype.hasOwnProperty.call(globalConfig, "testResults")) {
    // @ts-ignore
    setupAndRun(globalConfig.testResults, options); // Return the results as required by Jest

    return globalConfig;
  }
  /**
   * The default behaviour - run as Custom Reporter, in parallel with Jest.
   * https://facebook.github.io/jest/docs/en/configuration.html#reporters-array-modulename-modulename-options
   */


  this.onTestResult = (data, result) => {
    // Catch console logs per test
    if (result.console) {
      consoleLogs.push({
        filePath: result.testFilePath,
        logs: result.console
      });
    }
  };

  this.onRunComplete = (contexts, testResult) => setupAndRun(testResult, options, consoleLogs);
}
/**
 * Setup Jest HTML Reporter and generate a report with the given data
 */


const setupAndRun = (testResults, options, logs) => {
  const reporter = new HTMLReporter(testResults, options, logs);
  return reporter.generate();
};

module.exports = JestHtmlReporter;
